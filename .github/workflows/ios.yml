name: iOS workflow

# It's tempting to add a path filter here so that this only runs on changes to the iOS folder. However, that only looks at the most recent commit, so tests are incorrectly bypassed if several commits editing iOS are pushed with the latest one not touching iOS. Instead, we use a filter job below.
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Adapted from https://stackoverflow.com/questions/74772740/run-github-actions-if-branch-has-updated-files-from-a-specific-directory
  filter:
    name: Filter to iOS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history
      - name: Get changed iOS files
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          files: iOS/**
      - name: Run if any iOS files changed
        if: steps.changed-files.outputs.any_changed == 'true'
        run: echo "iOS is affected"
      - name: Stop if iOS files not changed
        if: steps.changed-files.outputs.any_changed != 'true'
        run: echo "iOS is not affected" && exit 1
  build:
    name: Build and Test iOS
    runs-on: macos-latest
    needs: [filter]

    defaults:
      run:
        working-directory: iOS

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set Default Scheme
        run: |
          scheme_list=$(xcodebuild -list -json | tr -d "\n")
          default=$(echo $scheme_list | ruby -e "require 'json'; puts JSON.parse(STDIN.gets)['project']['targets'][0]")
          echo $default | cat >default
          echo Using default scheme: $default
      - name: Build
        env:
          scheme: ${{ 'default' }}
          platform: ${{ 'iOS Simulator' }}
        run: |
          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)
          device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\(]+' | head -1 | awk '{$1=$1;print}' | sed -e "s/ Simulator$//"`
          if [ $scheme = default ]; then scheme=$(cat default); fi
          if [ "`ls -A | grep -i \\.xcworkspace\$`" ]; then filetype_parameter="workspace" && file_to_build="`ls -A | grep -i \\.xcworkspace\$`"; else filetype_parameter="project" && file_to_build="`ls -A | grep -i \\.xcodeproj\$`"; fi
          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`
          xcodebuild build-for-testing -scheme "$scheme" -"$filetype_parameter" "$file_to_build" -destination "platform=$platform,name=$device"
      - name: Test
        env:
          scheme: ${{ 'default' }}
          platform: ${{ 'iOS Simulator' }}
        run: |
          # xcrun xctrace returns via stderr, not the expected stdout (see https://developer.apple.com/forums/thread/663959)
          device=`xcrun xctrace list devices 2>&1 | grep -oE 'iPhone.*?[^\(]+' | head -1 | awk '{$1=$1;print}' | sed -e "s/ Simulator$//"`
          if [ $scheme = default ]; then scheme=$(cat default); fi
          if [ "`ls -A | grep -i \\.xcworkspace\$`" ]; then filetype_parameter="workspace" && file_to_build="`ls -A | grep -i \\.xcworkspace\$`"; else filetype_parameter="project" && file_to_build="`ls -A | grep -i \\.xcodeproj\$`"; fi
          file_to_build=`echo $file_to_build | awk '{$1=$1;print}'`
          xcodebuild test-without-building -scheme "$scheme" -"$filetype_parameter" "$file_to_build" -destination "platform=$platform,name=$device"
  # The SwiftLint in our normal build is a pretty old version of SwiftLint, because we're developing for an old SDK to support older devices. That means that it doesn't catch everything that latest will. This job will run a much newer SwiftLint. If it catches something that doesn't show up locally, it's very hard to debug from its logs. But, sometimes it will put comments onto the GitHub diff, and if not, you can add SwiftLint via the Swift Package Manager and enable it under Build Phases/Run Build Tool Plug-ins. This is the only way we can get newer SwiftLint running for us until we take a newer SDK, but running SwiftLint this way breaks current XCode.
  swiftLint:
    name: SwiftLint iOS
    runs-on: ubuntu-latest
    needs: [filter]

    defaults:
      run:
        working-directory: iOS

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: SwiftLint
        uses: norio-nomura/action-swiftlint@master
        with:
          args: --strict
